<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Panda_2134’s Blog | Stay Hungry,Stay Stupid</title>
<meta name="generator" content="Jekyll v3.6.2" />
<meta property="og:title" content="Panda_2134’s Blog" />
<meta name="author" content="panda_2134" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Stay Hungry,Stay Stupid" />
<meta property="og:description" content="Stay Hungry,Stay Stupid" />
<link rel="canonical" href="http://localhost:4000/" />
<meta property="og:url" content="http://localhost:4000/" />
<meta property="og:site_name" content="Panda_2134’s Blog" />
<script type="application/ld+json">
{"name":"Panda_2134’s Blog","description":"Stay Hungry,Stay Stupid","author":{"@type":"Person","name":"panda_2134"},"@type":"WebSite","url":"http://localhost:4000/","headline":"Panda_2134’s Blog","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="description" content="Stay Hungry,Stay Stupid"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/assets/css/style.css?v=ca581cfac24950b4053aaad38e9a666f577b9d12">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Panda_2134's Blog</h1>
      <h2 class="project-tagline">Stay Hungry,Stay Stupid</h2>
      
        <a href="http://github.com/panda2134/panda2134.github.io" class="btn">View on GitHub</a>
      
      
    </section>

    <section class="main-content">
      <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  	jax: ["input/TeX", "output/HTML-CSS"],
    "HTML-CSS": { webFont: "Neo-Euler" }
  });
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<style>
    .disdot {
      list-style:none;
    }
    @font-face{
		font-family:"PTsans";
		src:url("/assets/font/PTsans.ttf");
		font-size: 20px;
	}
	@font-face{
		font-family:"SourceCodePro";
		src:url("/assets/font/SourceCodePro-Regular.ttf");
		font-size: 20px;
	}
	.code{
		font-family:'SourceCodePro' !important;
    font-size: 20px !important;
	}
  code{
    font-family:'SourceCodePro' !important;
    font-size: 20px !important;
  }
	@media screen and (min-width: 800px) {
    .sidebar{
    	margin-top: 3rem;
		display: block;
  		float: right;
  		width: 300px;
	};
	.mainpg{
  		width: 740px;
  		font-family:'PTsans','Microsoft Yahei Light','Microsoft Yahei','simsun',sans-serif;
      font-size: 20px;
	}
    .mainpg-wrap{
	  width: 750px;
      margin-right: 4rem ;
    }
}
@media screen and (max-width: 800px){
    .sidebar{
      display: inline;
      width: 26%
    }
}
.widget-wrap {
  margin: 50px 0;
}
.widget {
  color: #777;
  text-shadow: 0 1px #fff;
  background: #ddd;
  -webkit-box-shadow: 0 -1px 4px #ccc inset;
  box-shadow: 0 -1px 4px #ccc inset;
  border: 1px solid #ccc;
  padding: 15px;
  border-radius: 3px;
}

.article-inner{
  padding:1rem;
  background: #fff;
  -webkit-box-shadow: 1px 2px 3px #ddd;
  box-shadow: 1px 2px 3px #ddd;
  border: 1px solid #ddd;
  border-radius: 3px;
}
</style>
<div class="sidebar">
    <div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=0&id=2042160423&auto=0&height=430"></iframe>
    </div>
    <div class="widget-wrap">
      <div class="widget">
      <div style="color:#159957">Categories:</div>
        
        <a href="/showCategory.html?cat=个人">个人</a> &#40;1&#41;
        <br/>
        
        <a href="/showCategory.html?cat=解题报告">解题报告</a> &#40;29&#41;
        <br/>
        
        <a href="/showCategory.html?cat=计划">计划</a> &#40;4&#41;
        <br/>
        
        <a href="/showCategory.html?cat=笔记">笔记</a> &#40;8&#41;
        <br/>
        
        <a href="/showCategory.html?cat=总结">总结</a> &#40;2&#41;
        <br/>
        
        <a href="/showCategory.html?cat=生活">生活</a> &#40;1&#41;
        <br/>
        
        <a href="/showCategory.html?cat=数论">数论</a> &#40;1&#41;
        <br/>
        
        <a href="/showCategory.html?cat=扩展欧拉定理">扩展欧拉定理</a> &#40;1&#41;
        <br/>
        
        <a href="/showCategory.html?cat=线段树">线段树</a> &#40;1&#41;
        <br/>
        
      </div>
    </div>
    <div class="widget-wrap">
      <div class="widget">
        <div style="color:#159957">Tags:</div>
        
        <a href="/showTags.html?tag=并查集">并查集</a> &#40;2&#41;
        <br/>
        
        <a href="/showTags.html?tag=生成树">生成树</a> &#40;2&#41;
        <br/>
        
        <a href="/showTags.html?tag=倍增LCA">倍增LCA</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=字符串">字符串</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=KMP">KMP</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=单调栈">单调栈</a> &#40;3&#41;
        <br/>
        
        <a href="/showTags.html?tag=单调队列">单调队列</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=动态规划">动态规划</a> &#40;14&#41;
        <br/>
        
        <a href="/showTags.html?tag=LIS">LIS</a> &#40;3&#41;
        <br/>
        
        <a href="/showTags.html?tag=组合数学">组合数学</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=路径行走DP">路径行走DP</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=LCS">LCS</a> &#40;2&#41;
        <br/>
        
        <a href="/showTags.html?tag=序列型DP">序列型DP</a> &#40;5&#41;
        <br/>
        
        <a href="/showTags.html?tag=二维平面DP">二维平面DP</a> &#40;3&#41;
        <br/>
        
        <a href="/showTags.html?tag=平衡树">平衡树</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=常数优化">常数优化</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=二分">二分</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=状压DP">状压DP</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=数学">数学</a> &#40;3&#41;
        <br/>
        
        <a href="/showTags.html?tag=背包">背包</a> &#40;2&#41;
        <br/>
        
        <a href="/showTags.html?tag=递推">递推</a> &#40;2&#41;
        <br/>
        
        <a href="/showTags.html?tag=悬线法">悬线法</a> &#40;2&#41;
        <br/>
        
        <a href="/showTags.html?tag=排序">排序</a> &#40;2&#41;
        <br/>
        
        <a href="/showTags.html?tag=贪心">贪心</a> &#40;5&#41;
        <br/>
        
        <a href="/showTags.html?tag=数论">数论</a> &#40;2&#41;
        <br/>
        
        <a href="/showTags.html?tag=逆序对">逆序对</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=树状数组">树状数组</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=统计贡献">统计贡献</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=最短路">最短路</a> &#40;4&#41;
        <br/>
        
        <a href="/showTags.html?tag=图论">图论</a> &#40;7&#41;
        <br/>
        
        <a href="/showTags.html?tag=BFS">BFS</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=构造">构造</a> &#40;2&#41;
        <br/>
        
        <a href="/showTags.html?tag=链表">链表</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=分块">分块</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=莫队">莫队</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=Link-Cut Tree">Link-Cut Tree</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=NOIP">NOIP</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=二分图">二分图</a> &#40;2&#41;
        <br/>
        
        <a href="/showTags.html?tag=匈牙利算法">匈牙利算法</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=字典序">字典序</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=HBOI2018">HBOI2018</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=提交答案">提交答案</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=python">python</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=导数">导数</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=FFT">FFT</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=NTT">NTT</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=多项式">多项式</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=网络流">网络流</a> &#40;5&#41;
        <br/>
        
        <a href="/showTags.html?tag=上下界网络流">上下界网络流</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=缩点">缩点</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=Tarjan">Tarjan</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=最小割">最小割</a> &#40;3&#41;
        <br/>
        
        <a href="/showTags.html?tag=Dijkstra">Dijkstra</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=平面图">平面图</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=二分答案">二分答案</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=最大权闭合子图">最大权闭合子图</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=莫比乌斯反演">莫比乌斯反演</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=期望">期望</a> &#40;2&#41;
        <br/>
        
        <a href="/showTags.html?tag=高斯消元">高斯消元</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=排序不等式">排序不等式</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=ISAP">ISAP</a> &#40;1&#41;
        <br/>
        
        <a href="/showTags.html?tag=最大流">最大流</a> &#40;1&#41;
        <br/>
        
        </div>
    </div>
    <div class="widget-wrap">
      <div class="widget">
      <div style="color:#159957">Friends</div>
	        <a href="https://chrt.github.io">chrt</a>
      		<a href="https://edgration.com">Edgration</a>
      		<a href="https://ksmeow.moe">KSKun</a>
	        <a href="https://anoxiacxy.github.io">Anoxiacxy</a>
	        <a href="http://cnblogs.com/zjp-shadow">zjp_shadow</a>
	        <a href="http://nonamenotitle.pub">nonamenotitle</a>
      <br/>
      </div>
    </div>
</div>
<div class="mainpg-wrap">
  <div class="mainpg">
    <h3><b style="color:#000000">Recent Blogs</b></h3>
    <ul class="disdot">
      
      <li>
        <div class="article-inner">
        <a href="/2018/03/17/ISAP" style="color:#154;"> <h1>ISAP算法学习笔记</h1> </a>
        <p>ISAP，即改进的SAP算法。</p>

<p>算法基于：如果每次在残量网络中从汇点开始反向BFS， s-t 距离是单调不减的。</p>

<p>流程如下：</p>

<p>首先用BFS从汇点出发计算每个点到汇点的距离标号。</p>

<p>Advance:</p>

<p>每次走满足 <script type="math/tex">d_v = d_u - 1</script> 的路径，即走最短路。维护每个点的当前弧。</p>

<p>（实践证明，只有ISAP需要当前弧优化……原始对偶加了之后反而更慢……Dinic加了之后有时候快很多，有时候慢一倍……）</p>

<p>Retreat:</p>

<p>当沿着允许弧无法增广的时候，说明需要更新距离标号，产生新的允许弧。</p>

<p>于是令 <script type="math/tex">d_u = \min \{ d_v \} + 1</script> . 再从 s 开始走允许弧。特别地，当残量网络中 <script type="math/tex">u(u \neq t)</script> 没有后继时，说明任何允许弧最终都不应该到达 <script type="math/tex">u</script> 点，因为从 <script type="math/tex">u</script> 点继续走无法到 <script type="math/tex">t</script> ，更无法增广。于是此时令 <script type="math/tex">d_u = n</script> ，即可排除 <script type="math/tex">u</script> 点。（ <script type="math/tex">n</script> 个点的无权图中最大距离标号小于等于 <script type="math/tex">n-1</script> ）</p>

<p>GAP优化：设每个距离标号 <script type="math/tex">d</script> 对应的点有 <script type="math/tex">num_d</script> 个。如果某次 Retreat 操作后，<script type="math/tex">num_d = 0</script> ，说明残量网络中 s-t 不连通，算法立刻结束。原因很简单：在这次修改距离标号之后，<script type="math/tex">d_s</script> 只会增大。在从 <script type="math/tex">s</script> 到 <script type="math/tex">t</script> 的过程中，距离标号逐渐由 <script type="math/tex">d_s</script> <strong>一步一步地</strong>减小到0. 如果在这个过程中距离标号出现了断层（“gap”），s-t 最短路长度一定是无穷大，即残量网络中 s-t 不连通。于是当前流即为最大流。</p>


        <a href="/2018/03/17/ISAP" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/03/15/walk" style="color:#154;"> <h1>[HNOI2013]游走</h1> </a>
        <h2 id="题意">题意</h2>

<p>一个无向简单连通图，边权为 <script type="math/tex">1\dots m</script> 的整数。问从点 1 随机游走到点 <script type="math/tex">n</script> 的最小期望距离。</p>

<h2 id="思路">思路</h2>

<p>刚看完《训练指南》上面的矩阵一部分，做一做相关省选题练练手，结果第一题就不会做……</p>

<p>这是最开始的错误思路：</p>

<p>我们对每个点显然可以列出递推式，设 <script type="math/tex">a_u</script> 为点 1 走到点 <script type="math/tex">u</script> 的期望距离。那么一定有：  <br />
<script type="math/tex">% <![CDATA[
a_u = \sum_{<u, v> \in \mathbb{E}} \frac{1}{\deg{u}}(a_v+w_{<u, v>}) %]]></script>
为什么？我们考虑是从哪个点 <script type="math/tex">v_i</script> 沿着边 <script type="math/tex">% <![CDATA[
<v_i, u> %]]></script> 走到 <script type="math/tex">u</script> 的。对于沿着每一条边 <script type="math/tex">% <![CDATA[
<v_i, u> %]]></script> 走到 <script type="math/tex">u</script> 点的情况，由全期望公式知，对应的期望值为 <script type="math/tex">% <![CDATA[
a_{v_i} + w_{<v_i, u>} %]]></script> . 所有情况加权平均即为上式。</p>

<p>但是我们并不知道每条边的长度啊？！这样就不能做了……</p>

<p>我们换个思路：不妨写出每个点期望经过的次数 <script type="math/tex">b_u</script> ，则
<script type="math/tex">% <![CDATA[
b_u = \sum_{<u, v> \in \mathbb{E}}\frac{b_v}{\deg v} %]]></script>
为什么是除以 <script type="math/tex">\deg v</script> 呢？不要忘了，每个点的期望经过次数等于 <strong>邻接弧</strong> 期望经过次数之和。而对于每条和 <script type="math/tex">u</script> 邻接的弧 <script type="math/tex">% <![CDATA[
<u, v> %]]></script> ，经过它到 <script type="math/tex">u</script> 的次数都是 <script type="math/tex">b_v / \deg v</script> ，因为到达邻接点 <script type="math/tex">v</script> 的期望次数为 <script type="math/tex">b_v</script> ，而又有 <script type="math/tex">1 / \deg v</script> 的概率经过弧 <script type="math/tex">% <![CDATA[
<v, u> %]]></script> ，根据期望定义和全期望公式，可得上式。</p>

<p>我们再来考虑不限定经过方向的前提下，每条弧的期望经过次数 <script type="math/tex">% <![CDATA[
c_{<u, v>} %]]></script>。显然有：  <br />
<script type="math/tex">% <![CDATA[
c_{<u, v>} = \frac{b_u}{\deg_u} + \frac{b_v}{\deg_v} %]]></script>
则答案为 <br />
<script type="math/tex">% <![CDATA[
ans = \sum_{<u, v> \in \mathbb{E}} c_{<u, v>} w_{<u, v>} %]]></script>
等等…… <script type="math/tex">\sum_i a_i b_i</script> 求最值？这不就是排序不等式么……</p>

<p>先高斯消元求 <script type="math/tex">{b_n}</script> ，再利用逆序和最小安排权值即可。由于是无向连通图，一定有解。</p>

<p>这个题目中，我学到了几点：</p>

<ol>
  <li>一定要灵活利用好期望的线性、全期望公式，更别忘了期望的定义式。</li>
  <li>点和边的对偶转化是很方便的。如果要求边相关期望，而点的期望更好求（一般都是这样），可以进行转化。</li>
  <li>最优化问题有时候可以用不等式解决。</li>
</ol>

<h2 id="代码">代码</h2>

<p>注意实现的一些细节，调了好久没调出来，看了Sengxian的题解才知道：</p>

<ol>
  <li>对于点 1 ，不能漏掉最开始的一次经过，也就是经过次数的期望要加上 1 。按照《训练指南》的说法，可以看成从虚拟的节点 0 以 1 的概率转移而来。</li>
  <li>对于点 <script type="math/tex">n</script> ，由于到了它就不再继续游走，比较特殊，我们不对它列方程解期望；对于一端是 <script type="math/tex">n</script> 的弧，我们只考虑向 <script type="math/tex">n</script> 的方向走的期望次数。</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
#define fst first
#define snd second
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Edge</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span> <span class="p">};</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">e_ptr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">deg</span><span class="p">[</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">],</span> <span class="n">head</span><span class="p">[</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">];</span> <span class="n">Edge</span> <span class="n">E</span><span class="p">[(</span><span class="n">MAXN</span><span class="o">*</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">];</span>
<span class="kt">double</span> <span class="n">b</span><span class="p">[</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">][</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">],</span> <span class="n">c</span><span class="p">[(</span><span class="n">MAXN</span><span class="o">*</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">];</span> 
<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">E0</span><span class="p">;</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dcmp</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">fabs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">AddEdge</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">E</span><span class="p">[</span><span class="o">++</span><span class="n">e_ptr</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Edge</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span><span class="p">,</span> <span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="p">};</span> <span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">e_ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">AddPair</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AddEdge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span> <span class="n">AddEdge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
    <span class="n">deg</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="n">deg</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="n">E0</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Init</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
        <span class="n">AddPair</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Gauss</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">double</span> <span class="n">A</span><span class="p">[</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">][</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">fabs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span> <span class="n">r</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">t</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Work</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">b</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="n">j</span><span class="p">;</span> <span class="n">j</span><span class="o">=</span><span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="n">b</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">deg</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">b</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Gauss</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// n-1个方程， n-1个变量
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">=</span> <span class="n">E0</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">double</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">fst</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">?</span> <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">fst</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">/</span> <span class="n">deg</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">fst</span><span class="p">]</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">);</span>
        <span class="kt">double</span> <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">snd</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">?</span> <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">snd</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">/</span> <span class="n">deg</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">snd</span><span class="p">]</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">);</span>
        <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">m</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="n">i</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%.3lf"</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Init</span><span class="p">();</span> <span class="n">Work</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>


        <a href="/2018/03/15/walk" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/03/14/greeting" style="color:#154;"> <h1>[六省联考2017]相逢是问候</h1> </a>
        <p>day1 没上200……不应该啊……正常点的话215应该没问题？</p>

<h2 id="题意">题意</h2>

<p>给定一个长为 <script type="math/tex">n (n \le 10^5)</script> 的序列，要求支持 2 个操作：</p>

<ol>
  <li>把某个区间每个元素 <script type="math/tex">a_i</script> 换成 <script type="math/tex">c^{a_i}</script> ，其中 <script type="math/tex">c</script> 是给定常数。</li>
  <li>求区间和</li>
</ol>

<h2 id="思路">思路</h2>

<p>PoPoQQQ大爷：这……这不是……上帝和集合的正确用法吗？</p>

<p>然而我做过上帝和集合的正确用法，却没能做出来这题 &gt;.&lt;</p>

<p>有扩展欧拉定理：
<script type="math/tex">a^b \equiv a^{b \text{ mod }\varphi(n) + [b \ge \varphi(n)]\cdot\varphi(n)} (\text{mod }n)</script>
根据上帝和集合的正确用法，这个可以递归下去求，由于 <script type="math/tex">\varphi(n)</script> 每次至少折半，复杂度是 <script type="math/tex">O(\lg n)</script> 级别的。</p>

<p>考试的时候，总是在想：在线段树上面记录什么信息，能够一次执行一个区间的递归求值操作呢？如果只记录加了多少次的话，每次求和就得暴力查，这样复杂度就是每次操作 <script type="math/tex">O(\lg n) - O(n\lg n)</script> 的了……最后也没想出来，交的暴力，发现线性筛求 <script type="math/tex">\varphi(n)</script> 被卡了QAQ</p>

<p>实际上，为什么不换个角度思考呢？与其说一次执行一个区间的递归求值，还不如每次暴力改，在 <script type="math/tex">O(\lg n)</script> 次之后，那个位置原来的值是什么已经无关紧要了，因为递归下去出现了 <script type="math/tex">\text{mod } 1</script> ，最后求出的值一定相同！于是就不用再修改了= =</p>

<p>我们来冷静分析一下复杂度。修改的话区间内每个元素暴力，所有元素最多改 <script type="math/tex">O(\lg n)</script> 次，考虑序列所有元素，最坏复杂度是 <script type="math/tex">O(n \lg^3 n)</script> （每次迭代+快速幂是 <script type="math/tex">O(\lg^2 n)</script> 的），再算上每次在线段树上面分解区间的 <script type="math/tex">O(\lg n)</script> ，总修改复杂度是 <script type="math/tex">O(n \lg^3 n + q_0 n) = O(n \lg^3 n)</script> 的，均摊到每次修改是 <script type="math/tex">O(\lg^3n)</script> 的。每次暴力改的时候维护下区间和，总查询复杂度是 <script type="math/tex">O(q_1 \lg n)</script> 的。</p>

<p>哲♂学分析一下，发现复杂度出现了 <script type="math/tex">O(\lg n) - O(n\lg n)</script> 这种东西，运用根号平衡的思想，也应该想到提高前一半复杂度，降低后一半复杂度？</p>

<p>其实这个思想和维护“区间开方-区间求和”也是类似的……</p>

<h2 id="代码">代码</h2>

<p>好像还有一种把快速幂的 <script type="math/tex">O(\lg n)</script> 去掉的方法？</p>


        <a href="/2018/03/14/greeting" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/03/13/wish" style="color:#154;"> <h1>[六省联考2017]分手是祝愿</h1> </a>
        <p>上午做了六省联考2017 Day2.</p>

<p>挂的一塌糊涂，除了某个做过的题 A 了之外其他题目加起来只有55. 这个题目的贪心都没想到。</p>

<p>cxy神犇接近AK。</p>

<p>技不如人， 如果不多刷题的话， 可能只有失败的后果吧。</p>

<p>现在也不要想别的了，挂了就是自己弱， 没别的。 就是自己弱。太弱了，就没有大学上了。</p>

<p>去除杂念， 专心刷题， 才有可能超越啊。</p>

<h2 id="思路">思路</h2>

<p>我们考虑50分的情况。</p>

<blockquote>
  <p>对于50%的数据, 满足 <script type="math/tex">n = k</script>.</p>
</blockquote>

<p><script type="math/tex">n = k</script> , 说明求期望变成了求最小步数。打个暴力可以发现, 最小步数一定小于 <script type="math/tex">n</script> .  为什么呢? 我们考虑构造一个方案来达到最小的步数。每个数的约数小于等于它本身，于是我们贪心地从右边往左边扫，每次碰到一个亮着的灯就按按钮。我们注意到，由于异或的定义，每个按钮最多按一次。所以总次数小于 <script type="math/tex">n</script>， 一定是可行解。如何证明其最优性？如果某个灯本来是亮的，可以分2种情况。由于它必须最后被按灭，要么它在扫到它之前就灭了，要么它在扫到它的时候被按灭。前者说明一次按灭了大于等于2个灯，贪心的答案不会更坏。后者也不会使得答案劣于最优解。如果某个灯是灭的，在按比它编号大的按钮的时候被点亮，我们可以发现，按比它编号大的按钮，一定是由于那个灯是亮的，因此不得不按。最优解不可能比当前贪心策略更好。</p>

<p>这种贪心实际上可以得到80分。</p>

<p>以上都还没有涉及到期望。我们现在来加入 <script type="math/tex">n \neq k</script> 的情况，这就需要建立期望的递推关系。</p>

<p>真的需要把当前的状态塞进期望递推式吗？<strong>动态规划和递推的状态设计，要看转移的需要</strong>。如果转移不需要完整的局面，就没必要把完整的局面塞进递推。显然，如果设每个开关 <script type="math/tex">i</script> 至少还需要按的次数为 <script type="math/tex">x_i</script> ，那么一定有 <script type="math/tex">x_i \in \{ 0, 1 \}</script>. 考虑当前全部开关加起来还需要按 <script type="math/tex">t</script> 次才能清零。这可以看做有 <script type="math/tex">t</script> 个 1 装在 <script type="math/tex">t</script> 个盒子里面，其他的盒子为空。任意取走某一个 1 ，此后的步数减少 1 ；往没有 1 的盒子里面放一个 1 ，此后的步数增加 1.</p>

<p>可以看出，转移只和全部开关加起来要按的次数有关。</p>

<p>设 <script type="math/tex">a_i</script> 表示当前还有 <script type="math/tex">i</script> 个 1 的情况下期望按多少次能全部按成0.此处的 <script type="math/tex">i</script> 就是刚才的 <script type="math/tex">t</script> .</p>

<p>于是：  <br />
​  <br />
<script type="math/tex">% <![CDATA[
\begin{equation}
a_i = 
\begin{cases}
i & 当 i \le k \\
1 + \frac{n - i}{n} \cdot a_{i+1} + \frac{i}{n} \cdot a_{i-1} & 当 i > k 
\end{cases}
\end{equation} %]]></script></p>

<p>这可以高斯消元求解。但是 <script type="math/tex">n \le 10^5</script> ，时间无法承受。</p>

<p>《训练指南》上面的 2 个关于马尔科夫过程的题，一个是高斯消元法，一个是手动消元。这里是不是可以手动消元呢？想想数学课上，学数列的时候，遇到这种式子常常移项差分。试一试：
​  <br />
<script type="math/tex">% <![CDATA[
\begin{align*}
\text{Let }b_i &= a_{i+1} - a_i \\
\Rightarrow b_i &= \frac{i \cdot b_{i-1} - n}{n - i}(i > k)
\end{align*} %]]></script></p>

<p>就可以一个一个递推了。</p>

<p>边界的处理？<script type="math/tex">b_k</script> 是不符合递推式的断点，怎么办？</p>

<p>换一边来推！  <br />
<script type="math/tex">% <![CDATA[
\begin{align*}
b_i &= \frac{i \cdot b_{i-1} - n}{n - i}(i > k) \\
\Rightarrow b_{i-1} &= \frac{(n-i)b_i+n}{i}(i > k) \\
\Rightarrow b_{i} &= \frac{(n - i - 1)b_{i+1}+n}{i+1}(i \ge k)
\end{align*} %]]></script>
结合 <script type="math/tex">b_{n-1} = 1</script> 这一结论（所有盒子里面都有 1 ，任意摸一个都可以减少一步），又有 <script type="math/tex">% <![CDATA[
\forall i < k, b_i = 1 %]]></script> ，可以得出答案。</p>

<p><em>疑问：题中给出的状态，不一定可达</em> <script type="math/tex">b_{n-1}</script> <em>，为何可以这么递推？</em></p>

<p>好像想通了…… <script type="math/tex">b_{n-1}</script> 只是递推的起点，我们要根据初始状态的最少步数来确定取 <script type="math/tex">{b_n}</script> 的哪一项。</p>

<p>考虑差分出的 <script type="math/tex">b_i</script> 的组合意义：从剩下 <script type="math/tex">i+1</script> 步到 <script type="math/tex">i</script> 步的期望操作数目。</p>


        <a href="/2018/03/13/wish" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/03/12/MobiusInversion" style="color:#154;"> <h1>莫比乌斯反演学习笔记</h1> </a>
        <h2 id="莫比乌斯函数">莫比乌斯函数</h2>

<p>我们定义  <br />
​            <br />
<script type="math/tex">% <![CDATA[
\begin{equation}
\mu(n) = \begin{cases}
	1 & \text{当} n = 1 \\
	(-1)^k & \text{当}n \text{为} k \text{个互异质数的积} \\
	0 & \text{当} n \text{某个质因子次数大于等于} 2
\end{cases}
\end{equation} \label{mobius-func} %]]></script></p>

<p>为什么这么定义?为了满足性质:    <br />
​               <br />
<script type="math/tex">\begin{equation} \sum_{d \backslash n} \mu (d) = [n = 1] \end{equation}</script></p>

<p>下面我们来证明上式.   <br />
​         <br />
当 <script type="math/tex">n = 1</script> 时显然成立.    <br />
​           <br />
当 <script type="math/tex">n \ge 2</script> 时,不妨设 <script type="math/tex">n = \prod_{i=1}^k p_i^{\alpha_i}</script>.  <script type="math/tex">n</script> 的恰含有 <script type="math/tex">r</script> 个互异质因数的因子有<script type="math/tex">\binom{k}{r}</script> 个.当它含有奇数个互异质因子时, 对答案贡献为 <script type="math/tex">-1</script> , 含偶数个互异质因子时贡献为 <script type="math/tex">1</script> .于是总的贡献为:         <br />
​            <br />
<script type="math/tex">% <![CDATA[
\begin{align*}
\sum_{d \backslash n} \mu (d) &= \binom{n}{0} - \binom{n}{1} + \binom{n}{2}- \cdots \\
&= \sum_{i=0}^k (-1)^i \binom{n}{i} \\
&= (1 - 1)^k \\
&= 0
\end{align*} %]]></script></p>

<p>得证.  <br />
​            <br />
从上面的证明过程可以看出, 其实莫比乌斯函数就是在模拟容斥原理, 不过容斥的对象是唯一分解式中的指数罢了. 把不同的质因数看成盒子, 指数看成球, 就转为了经典的球-盒模型.</p>

<h2 id="莫比乌斯反演">莫比乌斯反演</h2>

<h3 id="形式1枚举约数">形式1:枚举约数</h3>

<script type="math/tex; mode=display">\begin{align}
F(n) = \sum_{d \backslash n} f(d) \Leftrightarrow f(n) = \sum_{d \backslash n} \mu(d) F(\frac{n}{d}) \\
\end{align}</script>

<p>证明:     <br />
​                <br />
⇒:      <br />
​          <br />
<script type="math/tex">% <![CDATA[
\begin{align*}
	\sum_{d \backslash n} \mu(d) F(\frac{n}{d})	&= \sum_{d \backslash n} \mu(d) \sum_{k \backslash (n/d)} f(k) \\
	&= \sum_{d \backslash n} \sum_{k \backslash (n/d)} \mu(d) f(k) \\
	&= \sum_{k \backslash n} \sum_{d \backslash (n/k)} \mu(d) f(k) \\
	&= \sum_{k \backslash n} f(k) \sum_{d \backslash (n/k)} \mu(d) \\
	&= \sum_{k \backslash n} f(k) [n = k] \\
	&= f(n)
	\end{align*} %]]></script></p>

<p>⇐:  <br />
​         <br />
<script type="math/tex">% <![CDATA[
\begin{align*}
	\sum_{d \backslash n} f(d) &= \sum_{d \backslash n} \sum_{k \backslash d} \mu(k) F(\frac{d}{k}) \\
	&= \sum_{p \backslash n} \sum_{q \backslash (n/p)} \mu(p) F(q) \tag{Rocky Road方法}\\
	&= \sum_{q \backslash n} \sum_{p \backslash (n/q)} \mu(p) F(q) \\
	&= \sum_{q \backslash n} F(q) \sum_{p \backslash (n/q)} \mu(p) \\
	&= \sum_{q \backslash n} F(q) [n = q] \\
	&= F(n)
	\end{align*} %]]></script></p>

<p>得证.        <br />
​</p>
<h3 id="形式2枚举倍数">形式2:枚举倍数</h3>

<p>这个形式比较常用.         <br />
​            <br />
我们不妨假设 <script type="math/tex">n, d \le N</script> . 则:<br />
​            <br />
<script type="math/tex">F(n) = \sum_{n \backslash d}f(d) \Leftrightarrow f(n) = \sum_{n \backslash d} \mu(\frac{d}{n})F(d)</script></p>

<p>这个比较难证明……想了好久……          <br />
​           <br />
证明:          <br />
​                <br />
⇒:                      <br />
​              <br />
<script type="math/tex">% <![CDATA[
\begin{align*}
\sum_{n \backslash d} \mu(\frac{d}{n}) F(d) &= \sum_{k=1}^{+\infty}  \mu(k) F(nk) \\
&= \sum_{k=1}^{+\infty}\mu(k)\sum_{nk \backslash t} f(t) \\
&= \sum_{n \backslash t} f(t) \sum_{k \backslash (t / n)} \mu(k) \\
&= \sum_{n \backslash t} f(t) [t = n] \\
&= f(t)
\end{align*} %]]></script></p>

<p>⇐:          <br />
​                 <br />
<script type="math/tex">% <![CDATA[
\begin{align*}
	\sum_{n \backslash d} f(d)  &= \sum_{k=1}^{+\infty}f(nk) \\
	&= \sum_{k=1}^{+\infty} \sum_{nk \backslash m} \mu(\frac{m}{nk}) F(m) \\	
	&= \sum_{k=1}^{+\infty} \sum_{t=1}^{+\infty} \mu(t) F(nkt) \\	
	&= \sum_{t=1}^{+\infty} \mu(t) \sum_{k=1}^{+\infty} F(nkt) \\
	&= \sum_{k=1}^{+\infty} F(nk) \left(\sum_{p \backslash k} \mu(p)\right) \\
	&= \sum_{k=1}^{+\infty} F(nk) [k = 1] \\
	&= F(n)
	\end{align*} %]]></script></p>

<p>得证.</p>

<h2 id="一点重要的结论">一点重要的结论</h2>

<script type="math/tex; mode=display">n = \sum_{d \backslash n}\varphi(d)   \tag{欧拉函数的狄利克雷前缀和}</script>

<p>证明1：利用法里级数  <br />
这是《具体数学》的证明方法。名字很玄乎，其实很直观。</p>

<p>我们考察以 <script type="math/tex">n</script> 为底的所有真分数和1一起组成的集合。不妨假设 <script type="math/tex">n=12</script> . 则这些分数是：  <br />
<script type="math/tex">\frac{1}{12}, \frac{2}{12}, \frac{3}{12}, \frac{4}{12}, \frac{5}{12}, \frac{6}{12}, \frac{7}{12}, \frac{8}{12}, \frac{9}{12}, \frac{10}{12}, \frac{11}{12}, \frac{12}{12}</script>
化简后就变成了：    <br />
<script type="math/tex">\frac{1}{12},\frac{1}{6},\frac{1}{4},\frac{1}{3}, \frac{5}{12}, \frac{1}{2}, \frac{7}{12}, \frac{2}{3}, \frac{3}{4}, \frac{5}{6}, \frac{11}{12}, \frac{1}{1}</script>
按照分母分个组：  <br />
<script type="math/tex">\left(\frac{1}{1}\right),\left(\frac{1}{2}\right), \left(\frac{1}{3}, \frac{2}{3}\right), \left(\frac{4}{1}, \frac{4}{3}\right), \left(\frac{1}{6}, \frac{5}{6}\right),\left( \frac{1}{12}, \frac{5}{12}, \frac{7}{12}, \frac{11}{12}\right)</script>
分母里面出现了 <script type="math/tex">n</script> 的每个约数 <script type="math/tex">d</script> . 对于每个约数 <script type="math/tex">d</script> 对应的分组，分子上出现了 <script type="math/tex">\varphi(d)</script> 个小于等于 <script type="math/tex">d</script> 且与之互质的数。总共又有 <script type="math/tex">n</script> 个分数。也就是说所有约数的 <script type="math/tex">\varphi(n)</script> 之和就是 <script type="math/tex">n</script> . 写成式子就是上式。得证。</p>

<p>证明2：利用 <script type="math/tex">\mu</script> 函数的性质，构造出 <script type="math/tex">\mu(n)</script> ，再使用莫比乌斯反演消去（%Anoxiacxy）
<script type="math/tex">% <![CDATA[
\begin{align*}
\varphi(n) &= \sum_{1 \le i \le n} [i \perp n] \\
&= \sum_{1 \le i \le n} \sum_{d  \backslash \text{gcd}(i, n)} \mu(d) \\
&= \sum_{d \backslash n} \sum_{1 \le i \le n} \mu(d) [d \backslash i] \\
&= \sum_{d \backslash n} \mu(d) \frac{n}{d} \\
&\Rightarrow n = \sum_{d \backslash n} \varphi(n)
\end{align*} %]]></script>
QED.</p>

<h2 id="例题">例题</h2>

<ul>
  <li>BZOJ2301 [HAOI2011]Problem b</li>
  <li>莫比乌斯反演+数论分块，达到单组询问 <script type="math/tex">O(\sqrt{n})</script> ​的复杂度。</li>
</ul>

<hr />

<p>参考链接:</p>

<p><strong>强烈推荐:</strong><a href="https://wenku.baidu.com/view/fbec9c63ba1aa8114431d9ac.html">PoPoQQQ的PPT</a></p>

<p><a href="http://blog.csdn.net/outer_form/article/details/50588307">莫比乌斯反演定理证明</a></p>


        <a href="/2018/03/12/MobiusInversion" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/03/08/sushi-restaurant" style="color:#154;"> <h1>[六省联考2017]寿司餐厅</h1> </a>
        <p>省选提前到 4 月 6 日了，慌的要命，赶紧找找去年的题目做一做。</p>

<p><a href="https://www.luogu.org/problemnew/show/P3749">Luogu-3749</a></p>

<h2 id="思路">思路</h2>

<p>Kiana的美食评判标准的“记忆性”说明选择了多个区间，影响不会扩大。“选择即有对应的影响，选择了多个物品，影响不会扩大，求最大权和……” 不就是最大权闭合子图吗？</p>

<p>每个区间建 1 个点，每个代号建 1 个点，分别赋相应的权值，再找出最大权闭合子图即可。</p>

<h2 id="代码">代码</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
#define rep(i, x) for(int i = 1 ; i &lt;= (x); i++)
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mf">1e4</span><span class="p">,</span> <span class="n">MAXM</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">,</span> <span class="n">MAXL</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">MAXA</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">INF</span> <span class="o">=</span> <span class="mh">0x3f3f3f3f</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">PosSum</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">MAXL</span><span class="o">+</span><span class="mi">10</span><span class="p">],</span> <span class="n">W</span><span class="p">[</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">],</span> <span class="n">D</span><span class="p">[</span><span class="n">MAXL</span><span class="o">+</span><span class="mi">10</span><span class="p">][</span><span class="n">MAXL</span><span class="o">+</span><span class="mi">10</span><span class="p">],</span> <span class="n">ID</span><span class="p">[</span><span class="n">MAXL</span><span class="o">+</span><span class="mi">10</span><span class="p">][</span><span class="n">MAXL</span><span class="o">+</span><span class="mi">10</span><span class="p">];</span>

<span class="k">namespace</span> <span class="n">Maxflow</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Edge</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e_ptr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">head</span><span class="p">[</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">];</span> <span class="n">Edge</span> <span class="n">E</span><span class="p">[(</span><span class="n">MAXM</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">vis</span><span class="p">[</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">],</span> <span class="n">cur</span><span class="p">[</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">];</span>
    
    <span class="kt">void</span> <span class="nf">AddEdge</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">E</span><span class="p">[</span><span class="o">++</span><span class="n">e_ptr</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Edge</span><span class="p">)</span> <span class="p">{</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="p">};</span> <span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">e_ptr</span><span class="p">;</span>
        <span class="n">E</span><span class="p">[</span><span class="o">++</span><span class="n">e_ptr</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Edge</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="n">head</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="p">};</span> <span class="n">head</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">e_ptr</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="nf">BFS</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Q</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vis</span><span class="p">));</span>
        <span class="n">vis</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">Q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">Q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="n">j</span><span class="p">;</span> <span class="n">j</span><span class="o">=</span><span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="o">^</span><span class="mi">1</span><span class="p">].</span><span class="n">flow</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="o">^</span><span class="mi">1</span><span class="p">].</span><span class="n">cap</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">vis</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="nf">Augment</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">aug</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">s</span><span class="p">;</span> <span class="n">u</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">]].</span><span class="n">u</span><span class="p">)</span>
            <span class="n">aug</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span> <span class="n">E</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">]].</span><span class="n">cap</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">]].</span><span class="n">flow</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">s</span><span class="p">;</span> <span class="n">u</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">]].</span><span class="n">u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">E</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">]].</span><span class="n">flow</span> <span class="o">+=</span> <span class="n">aug</span><span class="p">;</span>
            <span class="n">E</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">^</span><span class="mi">1</span><span class="p">].</span><span class="n">flow</span> <span class="o">-=</span> <span class="n">aug</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">aug</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="nf">ISAP</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">s</span><span class="p">,</span> <span class="n">flow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">BFS</span><span class="p">();</span> <span class="n">memcpy</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">head</span><span class="p">));</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="o">++</span><span class="n">num</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
        <span class="k">while</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flow</span> <span class="o">+=</span> <span class="n">Augment</span><span class="p">();</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">j</span><span class="o">=</span><span class="n">cur</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="n">j</span><span class="p">;</span> <span class="n">j</span><span class="o">=</span><span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">flow</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">cap</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="n">p</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="n">u</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// 最后再走
</span>                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">slk</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="n">j</span><span class="p">;</span> <span class="n">j</span><span class="o">=</span><span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">flow</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">cap</span><span class="p">;</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">)</span> <span class="n">slk</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">slk</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
                <span class="p">}</span>
                <span class="k">if</span><span class="p">(</span><span class="o">--</span><span class="n">num</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                <span class="o">++</span><span class="n">num</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">slk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="n">cur</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
                <span class="k">if</span><span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="n">s</span><span class="p">)</span> <span class="n">u</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">]].</span><span class="n">u</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">flow</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="n">readint</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">f</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="kt">char</span> <span class="n">c</span><span class="o">=</span><span class="n">getchar</span><span class="p">();</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span> <span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">==</span><span class="sc">'-'</span><span class="p">)</span><span class="n">f</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">c</span><span class="o">=</span><span class="n">getchar</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span> <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="n">c</span><span class="o">-</span><span class="sc">'0'</span><span class="p">;</span> <span class="n">c</span><span class="o">=</span><span class="n">getchar</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">f</span><span class="o">*</span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Init</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span> <span class="n">M</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span>
    <span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span>
    <span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="n">rep</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span>
        <span class="n">ID</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">idx</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">MAXA</span><span class="p">)</span>
        <span class="n">W</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">M</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">W</span><span class="p">[</span><span class="n">ID</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">Maxflow</span><span class="o">::</span><span class="n">AddEdge</span><span class="p">(</span><span class="n">ID</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">INF</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">W</span><span class="p">[</span><span class="n">ID</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="n">Maxflow</span><span class="o">::</span><span class="n">AddEdge</span><span class="p">(</span><span class="n">ID</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">ID</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">INF</span><span class="p">);</span>
                <span class="n">Maxflow</span><span class="o">::</span><span class="n">AddEdge</span><span class="p">(</span><span class="n">ID</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">ID</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">INF</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="n">Maxflow</span><span class="o">::</span><span class="n">n</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">MAXA</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">Maxflow</span><span class="o">::</span><span class="n">s</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">MAXA</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Maxflow</span><span class="o">::</span><span class="n">t</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">MAXA</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">MAXA</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PosSum</span> <span class="o">+=</span> <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">Maxflow</span><span class="o">::</span><span class="n">AddEdge</span><span class="p">(</span><span class="n">Maxflow</span><span class="o">::</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">Maxflow</span><span class="o">::</span><span class="n">AddEdge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Maxflow</span><span class="o">::</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Work</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">PosSum</span> <span class="o">-</span> <span class="n">Maxflow</span><span class="o">::</span><span class="n">ISAP</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Init</span><span class="p">();</span> <span class="n">Work</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>


        <a href="/2018/03/08/sushi-restaurant" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/03/08/nuts-cake" style="color:#154;"> <h1>[HNOI2013]切糕</h1> </a>
        <p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3144">bzoj3144</a></p>

<h2 id="题意">题意</h2>

<p>给出一个 <script type="math/tex">P \times Q \times R</script> 的长方体，横着切一刀，使得在满足相邻切点 <script type="math/tex">z</script> 轴距离小于 <script type="math/tex">D</script> 的前提下，切面权值和最小。</p>

<h2 id="思路">思路</h2>

<p>题中是个显然的最小割模型，但是“某些点不能同时割”的限制比较棘手，不是很好处理……</p>

<p>尝试了几种建图方法，但都没办法证明正确性。看了题解才发现其中一种几乎就是正解……</p>

<p><strong>对于最小割相关问题，思考的时候不应该套最大流的“容量”等概念，而要抓住割的性质：</strong></p>

<ol>
  <li>割使得 <script type="math/tex">s-t</script> 不连通</li>
  <li>割把点划分为 2 个集合</li>
</ol>

<p>其中，后者较容易从题中看出，从而建立出相应的模型。但是本题所应用的第一个性质就没有那么显然了。</p>

<p>我们紧扣第一个性质来设计模型。</p>

<blockquote>
  <p>割使得 <script type="math/tex">s-t​</script> 不连通 <script type="math/tex">\Leftrightarrow​</script> 使得 <script type="math/tex">s-t​</script> 连通的一定不是割</p>
</blockquote>

<p>由此我们可以设法让某些点对应的边一定不会同时被割。方法就是加边，使得仅仅去掉那些点对应的边之后，图仍然连通（这样它们就不会一起选入最小割了）。</p>

<p>具体建图如下：</p>

<p>对于每个点 <script type="math/tex">(i, j, k)</script>， 我们从它向 <script type="math/tex">(i, j, k+1)</script> 对应点连边。边权为该点的不和谐度。同时我们从它向 <script type="math/tex">(i', j' ,k-d)</script> 对应点连边，权值为 <script type="math/tex">\infty</script> 。我们考察割去 <script type="math/tex">(i, j, k)</script> 以及 <script type="math/tex">(i',j',k-d-1)</script> 对应边之后的情况。下图中有 <script type="math/tex">s=9, t=10</script>。假设 <script type="math/tex">d=2</script> ，而我们想禁止 <script type="math/tex">3,5</script> 号点对应的边，即 <script type="math/tex">% <![CDATA[
<4,10>,<5,6> %]]></script> 同时选入割中。我们就连边 <script type="math/tex">% <![CDATA[
<4, 6> %]]></script> ，权值无穷大。这样的话，即使我们移除了 <script type="math/tex">% <![CDATA[
<4,10>, <5,6> %]]></script> 两条边，<script type="math/tex">s-t</script> 通过蓝色路径仍然可以连通。</p>

<p><img src="/img/cake.png" alt="" /></p>

<h2 id="代码">代码</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
#define rep(i, x) for(int i = 1; i &lt;= (x); i++)
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">MAXL</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">,</span> <span class="n">MAXM</span> <span class="o">=</span> <span class="mf">1e6</span><span class="p">,</span> <span class="n">INF</span> <span class="o">=</span> <span class="mh">0x3f3f3f3f</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">di</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span> <span class="n">dj</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">};</span>

<span class="k">namespace</span> <span class="n">Maxflow</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">Edge</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">};</span>
	
	<span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e_ptr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">head</span><span class="p">[</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">];</span> <span class="n">Edge</span> <span class="n">E</span><span class="p">[(</span><span class="n">MAXM</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">cur</span><span class="p">[</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">MAXN</span><span class="o">+</span><span class="mi">10</span><span class="p">];</span>
	
	<span class="kt">void</span> <span class="nf">AddEdge</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">E</span><span class="p">[</span><span class="o">++</span><span class="n">e_ptr</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Edge</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="p">};</span> <span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">e_ptr</span><span class="p">;</span>
		<span class="n">E</span><span class="p">[</span><span class="o">++</span><span class="n">e_ptr</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Edge</span><span class="p">)</span> <span class="p">{</span> <span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="n">head</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="p">};</span> <span class="n">head</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">e_ptr</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="kt">bool</span> <span class="nf">BFS</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Q</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>
		<span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">Q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">Q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="n">j</span><span class="p">;</span> <span class="n">j</span><span class="o">=</span><span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">flow</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">cap</span><span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">if</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
					<span class="k">else</span> <span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="kt">int</span> <span class="nf">DFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flow</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">t</span> <span class="o">||</span> <span class="n">flow</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">flow</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">flow</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">j</span><span class="o">=</span><span class="n">cur</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="n">j</span><span class="p">;</span> <span class="n">j</span><span class="o">=</span><span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>	
			<span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">flow</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">cap</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">aug</span> <span class="o">=</span> <span class="n">DFS</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">c</span><span class="o">-</span><span class="n">f</span><span class="p">));</span>
				<span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">flow</span> <span class="o">+=</span> <span class="n">aug</span><span class="p">;</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="o">^</span><span class="mi">1</span><span class="p">].</span><span class="n">flow</span> <span class="o">-=</span> <span class="n">aug</span><span class="p">;</span>
				<span class="n">res</span> <span class="o">-=</span> <span class="n">aug</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">flow</span> <span class="o">-</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="kt">int</span> <span class="nf">Dinic</span><span class="p">()</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">MaxFlow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CurFlow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">BFS</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">head</span><span class="p">));</span>
			<span class="k">while</span><span class="p">(</span> <span class="p">(</span><span class="n">CurFlow</span> <span class="o">=</span> <span class="n">DFS</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">INF</span><span class="p">))</span> <span class="p">)</span>
				<span class="n">MaxFlow</span> <span class="o">+=</span> <span class="n">CurFlow</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">MaxFlow</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">V</span><span class="p">[</span><span class="n">MAXL</span><span class="o">+</span><span class="mi">10</span><span class="p">][</span><span class="n">MAXL</span><span class="o">+</span><span class="mi">10</span><span class="p">][</span><span class="n">MAXL</span><span class="o">+</span><span class="mi">10</span><span class="p">];</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">readint</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">f</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="kt">char</span> <span class="n">c</span><span class="o">=</span><span class="n">getchar</span><span class="p">();</span>
	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span> <span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">==</span><span class="sc">'-'</span><span class="p">)</span><span class="n">f</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">c</span><span class="o">=</span><span class="n">getchar</span><span class="p">();</span> <span class="p">}</span>
	<span class="k">while</span><span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span> <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="n">c</span><span class="o">-</span><span class="sc">'0'</span><span class="p">;</span> <span class="n">c</span><span class="o">=</span><span class="n">getchar</span><span class="p">();</span> <span class="p">}</span>
	<span class="k">return</span> <span class="n">f</span><span class="o">*</span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">idx</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">P</span> <span class="o">*</span> <span class="n">Q</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Q</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">valid</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">P</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">Q</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Init</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">using</span> <span class="k">namespace</span> <span class="n">Maxflow</span><span class="p">;</span>
	<span class="n">P</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span> <span class="n">R</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span> <span class="n">D</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span>
	<span class="n">rep</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span> <span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span> <span class="n">rep</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">MAXN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">MAXN</span><span class="p">;</span>
	<span class="n">rep</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">R</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span> <span class="n">rep</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
		<span class="n">AddEdge</span><span class="p">(</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]);</span>
	<span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span> <span class="n">rep</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AddEdge</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">INF</span><span class="p">);</span>
		<span class="n">AddEdge</span><span class="p">(</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">R</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">R</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span> <span class="n">rep</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span> 
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">D</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> 
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dir</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">ni</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">di</span><span class="p">[</span><span class="n">dir</span><span class="p">],</span> <span class="n">nj</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">dj</span><span class="p">[</span><span class="n">dir</span><span class="p">];</span>
				<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">valid</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">nj</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
				<span class="n">AddEdge</span><span class="p">(</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">nj</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="n">D</span><span class="p">),</span> <span class="n">INF</span><span class="p">);</span>
			<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Work</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Maxflow</span> <span class="o">::</span> <span class="n">Dinic</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Init</span><span class="p">();</span> <span class="n">Work</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>


        <a href="/2018/03/08/nuts-cake" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/03/06/weird-game" style="color:#154;"> <h1>[SCOI2012]奇怪的游戏</h1> </a>
        <p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2756">BZOJ2756</a></p>

<h2 id="题意">题意</h2>

<p>给出一个 <script type="math/tex">n \times m</script> 的矩阵，初始每个格子有一个正整数。每次可以给相邻两个格子加1，求最少操作多少次使得矩阵里面数字相同。</p>


        <a href="/2018/03/06/weird-game" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/03/06/Altitude" style="color:#154;"> <h1>[NOI2010]海拔</h1> </a>
        <p>链接：<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2007">bzoj2007</a></p>

<h2 id="思路">思路</h2>

<p>​	经过思考可以发现2个结论：</p>

<ol>
  <li>选0/1外的值作为海拔没有必要
    <ul>
      <li>小于0的值改为0，大于1的值改为1，答案不会更差。</li>
      <li>对(0, 1)之间的值，不如选0/1更优。</li>
    </ul>
  </li>
  <li>海拔为0/1的分别只有一个连通块
    <ul>
      <li>如果1有≥2个连通块，把不包含(n, n)的连通块拍扁，答案不会更差。</li>
    </ul>
  </li>
</ol>

<p>然后就转化为了平面图最小割。</p>

<p>注意一点：最小割是可以绕圈子的！所以不能忽略从南到北、从东到西的边！</p>


        <a href="/2018/03/06/Altitude" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/03/02/King" style="color:#154;"> <h1>[BZOJ2893]征服王</h1> </a>
        <p>链接：<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2893">BZOJ2893</a></p>

<h2 id="题意">题意</h2>

<p>给定一个有向图，以及每次行走的起点终点集合。每次只能在起点集合开始，终点集合结束。求最少多少次行走可以覆盖每个节点。</p>


        <a href="/2018/03/02/King" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/02/26/NetworkFlow" style="color:#154;"> <h1>网络流常见建模总结</h1> </a>
        <p>自己对最近网络流学习的一些整理和理解……</p>

<p>如果有什么错误，请立即纠正，非常感谢。</p>

<p>这边Blog的排版估计很渣……我懒得管了，丢个 <script type="math/tex">\LaTeX</script> 版的吧……<a href="../downloads/2018-02-26-NetworkFlow.pdf">戳我</a></p>

<p><strong>UPD:</strong>发现洛谷上面的网络流题目严重不全……这么多年省选也不会只考了10道网络流啊……翻了翻hzwer的博客，屯了40几题，准备先用一个星期做个二十几道，剩下的边练DP边带着做</p>

<h1 id="我已经做了-8-题">我已经做了 8 题</h1>


        <a href="/2018/02/26/NetworkFlow" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/02/23/poly" style="color:#154;"> <h1>基础多项式算法</h1> </a>
        <p>慢慢填吧，毕竟除了FFT之外HBOI都没考过，先学好数据结构，图论和DP。</p>


        <a href="/2018/02/23/poly" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/02/19/nodes" style="color:#154;"> <h1>[NOI2016] 旷野大计算</h1> </a>
        <p><a href="http://uoj.ac/problem/224">UOJ-224</a></p>

<p>神题。</p>

<p>扑通一声跪下来，千古神犇vfk。</p>

<hr />

<p>早就听说了这个造计算机题。正好，前几天上洛谷的省选课，这个题目作为提答作业布置了下来。于是我就开始了我的愉快作死之旅啦~</p>

<p>自己xjb乱搞，搞了56pts，发现不会做了XD</p>

<p>于是参考了<a href="https://chrt.github.io/2017/05/17/noi2016-nodes/">chrt的题解</a>和<a href="https://panda2134.github.io/downloads/noi2016-nodes-vfleaking.pdf">vfleaking的slide</a>，各种卡，终于拿到了95pts…</p>

<p>未完待续</p>


        <a href="/2018/02/19/nodes" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/02/12/HBOI2018Plan" style="color:#154;"> <h1>省选计划</h1> </a>
        <h2 id="省选计划">省选计划</h2>

<p>省选知识点如下，希望大家能监督我QAQ</p>

<p>如果发现这边很久都没有打勾的话就在QQ上面喷我吧</p>

<p>以及如果看到我水群就让我回去学OI</p>

<p>希望能在省选之前把 <script type="math/tex">3/4</script> 的勾打上吧……</p>


        <a href="/2018/02/12/HBOI2018Plan" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/01/22/transform" style="color:#154;"> <h1>[NOI2009]变换序列</h1> </a>
        <p>链接：<a href="https://www.luogu.org/problemnew/show/P1963">Luogu-P1963</a></p>

<h2 id="思路">思路</h2>
<p>这个题目可以看出你真正理解了匈牙利算法没有。</p>

<p>首先我们可以建立二分图的模型：每个位置可以有2种取值，于是我们把位置作为左边的点，取值作为右边的点。然后进行二分图匹配，只要有完美匹配，完美匹配就是一个可行解。</p>


        <a href="/2018/01/22/transform" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/01/20/NOIP2017" style="color:#154;"> <h1>NOIP2017游记</h1> </a>
        <p>考完NOIP已经2个月了，也是时候写个游记了。</p>


        <a href="/2018/01/20/NOIP2017" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/01/18/MagicForest" style="color:#154;"> <h1>[NOI2014]魔法森林</h1> </a>
        <p>链接：<a href="https://www.luogu.org/problemnew/show/P2387" title="Luogu-P2387">Luogu-P2387</a></p>

<p>这是我做的第一道非模板LCT题目……自己并没有想出来，看题解也看了好久，于是总结下做这个题目的思路。</p>

<h2 id="题意">题意</h2>

<p>给出一个<script type="math/tex">n</script>个点，<script type="math/tex">m</script>条边的无向图，每条边都有权值<script type="math/tex">a_i,b_i</script>，求一条从点<script type="math/tex">1</script>到点<script type="math/tex">n</script>的路径，使得这条路径上边的<script type="math/tex">a_i,b_i</script>最大值之和最小。<script type="math/tex">2 \leq n \leq 5 \times 10^4, 0 \leq m \leq 1 \times 10^5</script>。</p>


        <a href="/2018/01/18/MagicForest" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/01/16/MosAlgorithm" style="color:#154;"> <h1>莫队笔记</h1> </a>
        <p>莫队是一种<strong>离线</strong>解决区间查询问题的算法。</p>

<p>记得 NOIP 之前那段时间，见到一道查询区间颜色种类数目的题目，标签是树状数组。想了很久也没有想出来怎么用树状数组做，看题解才知道有莫队这种逆天的东西……srOOrz</p>

<h2 id="普通莫队">普通莫队</h2>

<p>以查询区间颜色种类数目为例。为了方便，假定元素个数为 <script type="math/tex">n</script> ，查询数目为 <script type="math/tex">q</script> .</p>

<p>暴力开桶扫一遍，复杂度是 <script type="math/tex">O(qn)</script> 的。有没有更高效的算法呢？</p>

<p>如果已经扫描到区间 <script type="math/tex">[L,R]</script> ，那么转移到 <script type="math/tex">[L, R+1]</script>，  <script type="math/tex">[L+1, R]</script>，  <script type="math/tex">[L, R-1]</script>，  <script type="math/tex">[L-1, R]</script>， 都可以在 <script type="math/tex">O(1)</script> 的复杂度内完成。既然是离线做，也许可以以某种顺序处理所有询问，利用相邻询问的共同信息，来达到较优化的复杂度。</p>

<p>如何利用呢？</p>


        <a href="/2018/01/16/MosAlgorithm" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/01/12/drink" style="color:#154;"> <h1>雅礼集训day12-drink</h1> </a>
        <h2 id="题面">题面</h2>

<p>小C桌上有<script type="math/tex">n(n \leq 10^6)</script>杯水排成一行,第<script type="math/tex">i</script>杯水中有<script type="math/tex">a_i</script>单位体积的水. 他会选择一个区间<script type="math/tex">[l, r]</script>,
并拿一个初始为空的杯子(杯子的容积无限大),他可以重复无限次以下操作:
• 选定任意一杯水<script type="math/tex">i</script>, <script type="math/tex">i \in [l, r]</script>.
• 使i和它拿着的杯子里的水的体积变为它们的平均值.
小C希望进行若干操作后最大化杯子里的水的体积,设<script type="math/tex">g(l, r)</script>为这个最大值.你需要求:
<script type="math/tex">\sum{i=1}^n\sum{j=i}^n\frac{g(i,j)}{n^2}</script></p>


        <a href="/2018/01/12/drink" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2018/01/02/WCTodo" style="color:#154;"> <h1>WC2018学习计划</h1> </a>
        <p>离WC2018只有一个月了……</p>

<p>雅礼集训：</p>
<ul>
  <li>点/链分治</li>
  <li>Mobius反演</li>
  <li>Prufer序列   （做题）</li>
  <li>FFT DFT FWT 多项式各种操作</li>
  <li>网络流和各种建模</li>
  <li>博弈DP</li>
</ul>


        <a href="/2018/01/02/WCTodo" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/11/10/noip2017-review" style="color:#154;"> <h1>NOIP总结</h1> </a>
        <p>更新中</p>

<p><strong>UPD:暂时鸽了</strong></p>


        <a href="/2017/11/10/noip2017-review" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/11/08/logistics-transportation" style="color:#154;"> <h1>[ZJOI2006]物流运输</h1> </a>
        <p>链接:<a href="https://www.luogu.org/problemnew/show/1772">Luogu-P1772</a></p>
<h2 id="分析">分析</h2>
<p>在输入时对每个码头的不可用时间进行差分。假设某一段连续的时间<script type="math/tex">[t_1,t_2]</script>选择同一条运输路线，则可以通过Dijkstra求出这段时间的<script type="math/tex">s \rightarrow t</script>最短路长度，记作<script type="math/tex">cost[t_1][t_2]</script>。总时间是<script type="math/tex">t</script>，点数目是<script type="math/tex">n</script>，那么预处理每个时间段内选择同一条路的代价的时间复杂度是<script type="math/tex">O(n) \cdot O(t^2) \cdot O(n \log n) = O(n^2 t^2 \log n)</script>。显然是可以承受的。</p>


        <a href="/2017/11/08/logistics-transportation" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/11/06/yugu-r8-b" style="color:#154;"> <h1>浴谷八连测-R8-B</h1> </a>
        <h2 id="题意">题意</h2>
<p>给定<script type="math/tex">n</script>个人的<script type="math/tex">m</script>个关系，形如:<script type="math/tex">x, y, z</script>，表示<script type="math/tex">x</script>比<script type="math/tex">y</script>的<script type="math/tex">z</script>学科成绩高。求1号学生在最坏和最好情况下的排名。         <br />
学科数目<script type="math/tex">\leq 3,2\leq n \leq 50000, 2\leq m \leq 10^6</script>。</p>


        <a href="/2017/11/06/yugu-r8-b" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/11/06/PiggyBack" style="color:#154;"> <h1>[USACO14DEC]Piggy Back</h1> </a>
        <p>链接:<a href="https://www.luogu.org/problemnew/show/3110">Luogu-P3110</a></p>
<h2 id="分析">分析</h2>
<p>分两种情况讨论。</p>

<ol>
  <li><script type="math/tex">P \leq B+E</script> 。考虑二者在某个点处相遇。在这个点后两个人如果分别走，一定是沿着到<script type="math/tex">N</script>的最短路。于是显然背着走更好。</li>
  <li><script type="math/tex">P>B+E</script>。二者相遇后各自独立地沿着到<script type="math/tex">N</script>的最短路走（其实是同一条路），比背着走更好。</li>
</ol>


        <a href="/2017/11/06/PiggyBack" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/11/05/yugu-r7-b" style="color:#154;"> <h1>浴谷八连测-R7-B</h1> </a>
        <h2 id="题意">题意</h2>
<p>给定一个序列<script type="math/tex">\{a_i\}</script>，求它的每个子区间的逆序对数和。包括长度为1的区间。
对于<script type="math/tex">60\%</script>的数据，<script type="math/tex">n \leq 1000</script>； 对于<script type="math/tex">100\%</script>的数据，<script type="math/tex">n \leq 1000000</script>。</p>


        <a href="/2017/11/05/yugu-r7-b" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/11/05/irreversible-reboot" style="color:#154;"> <h1>浴谷八连测-R6-A - 不可逆的重启动</h1> </a>
        <h2 id="题意">题意</h2>
<p>求两个串<script type="math/tex">A</script>,<script type="math/tex">B</script>的最长公共子序列。  <br />
对于70%的数据，满足 <script type="math/tex">|A|,|B| \leq 1000</script>    <br />
对于100%的数据，满足 <script type="math/tex">|A| \leq 10^{6},|B| \leq 1000</script>，所有字符都是小写字母。</p>


        <a href="/2017/11/05/irreversible-reboot" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/11/04/number_theory" style="color:#154;"> <h1>数论基础</h1> </a>
        <p>填坑ing…</p>

<h2 id="概述">概述</h2>
<p>数论是研究整数的学问。初等数论的基础主要包括同余，扩展欧几里得定理，费马小定理，欧拉定理等。</p>


        <a href="/2017/11/04/number_theory" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/10/19/bus" style="color:#154;"> <h1>[NOIP2011]观光公交</h1> </a>
        <p>链接：<a href="https://www.luogu.org/problem/show?pid=1315">Luogu-P1315</a></p>

<p>这个题目是在某模拟赛中看到的……并没有做过，当时认为是DP，没有注意到加速器会影响等车的时间，认为只影响坐车的时间。想到了差分。考试结束之前20分钟才发现不满足无后效性，于是完挂爆0。</p>
<h2 id="分析">分析</h2>

<h3 id="why-greedy">Why Greedy?</h3>

<ul>
  <li>DP的状态难以设计，而且无法转移</li>
  <li>是序列问题，也没有明显的元素间关系</li>
  <li>最小化旅行的时间，是最优化问题
最优化 <script type="math/tex">\Rightarrow</script> DP/贪心</li>
</ul>

<p>既然DP不行，就只有贪心咯</p>


        <a href="/2017/10/19/bus" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/08/20/cook" style="color:#154;"> <h1>烹调方案</h1> </a>
        <p>链接：<a href="https://www.luogu.org/problem/show?pid=1417">Luogu-P1417</a></p>

<h2 id="思路">思路</h2>
<p>看上去是一个01背包，不过价值随着时间的推移而改变，怎么办？   <br />
先考虑2个物品的情况，即进行基于交换的贪心。时间足够的时候，到底是先取物品1再取物品2，还是先取物品2再取物品1。如果考虑清楚了2个物品的情况，就可以进行排序，再利用动态规划得解。</p>


        <a href="/2017/08/20/cook" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/08/20/chess" style="color:#154;"> <h1>[ZJOI2007]棋盘制作</h1> </a>
        <p>链接：<a href="https://www.luogu.org/problem/show?pid=1169">Luogu-P1169</a></p>

<h2 id="题意">题意</h2>
<p>在一个<script type="math/tex">N \times M</script>的矩阵内，找出最大的、像国际象棋棋盘一样黑白交错的正方形和矩形。</p>

<h2 id="思路">思路</h2>
<p>看到第一问，显然可以用二维平面DP完成：考虑设计状态<script type="math/tex">f(i,j,k)</script>：以<script type="math/tex">(i,j)</script>为右下角的最大正方形。k=1表示在这个正方形中<script type="math/tex">(i,j)</script>为黑，反之<script type="math/tex">(i,j)</script>为白。因为要求黑白交错，所以把黑白也加入状态。</p>


        <a href="/2017/08/20/chess" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/08/19/maxsqr" style="color:#154;"> <h1>悬线法学习笔记</h1> </a>
        <h2 id="定义">定义</h2>

<h3 id="概念">概念</h3>
<p><strong>有效子矩形</strong>：内部不含有任何障碍点的矩形。  <br />
<strong>极大有效子矩形</strong>：一个有效子矩形，如果不存在一个比它更大而且包含它的有效子矩形，就称它为极大有效子矩形。  <br />
<strong>最大有效子矩形</strong>：整个矩形中面积最大的有效子矩形。  <br />
约定使用<script type="math/tex">S</script>表示障碍点的数量，整个矩形的大小为<script type="math/tex">N \times M</script>。</p>


        <a href="/2017/08/19/maxsqr" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/08/19/eatfish" style="color:#154;"> <h1>创意吃鱼法</h1> </a>
        <p>链接：<a href="https://www.luogu.org/problem/show?pid=1736">Luogu-P1736</a></p>
<h2 id="题目大意">题目大意</h2>
<p>有一个<script type="math/tex">n \times m</script>的矩阵，要在里面寻找一个尽可能大的正方形，使得这个正方形某条对角线上都是1，其他地方都是0。求这个正方形对角线长。</p>


        <a href="/2017/08/19/eatfish" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/08/18/domino" style="color:#154;"> <h1>多米诺骨牌</h1> </a>
        <p>链接：<a href="https://www.luogu.org/problem/show?pid=1282">Luogu-P1282</a></p>

<h2 id="审题">审题</h2>
<p>一个骨牌转与不转，改变了两行之间的差值。要求用最少的旋转次数，达到最小差值。</p>


        <a href="/2017/08/18/domino" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/08/17/AngryBirds" style="color:#154;"> <h1>[NOIP2016]愤怒的小鸟</h1> </a>
        <p>题目链接：</p>

<p>LYOJ:<del><a href="https://ly.men.ci/problem/104">愤怒的南小鸟</a></del></p>

<p>Luogu:<a href="https://www.luogu.org/problem/show?pid=2831">愤怒的小鸟</a></p>

<p>题目较长，请在OJ上查看</p>


        <a href="/2017/08/17/AngryBirds" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/08/14/dpsolution" style="color:#154;"> <h1>占坑</h1> </a>
        <p>题解占坑列表：</p>
<ul>
  <li>***棋盘制作</li>
  <li>***烹调方案</li>
  <li>***垃圾陷阱</li>
</ul>


        <a href="/2017/08/14/dpsolution" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/07/31/buylow" style="color:#154;"> <h1>[USACO]低价购买</h1> </a>
        <p>链接：<a href="https://www.luogu.org/problem/show?pid=1108">Luogu-P1108</a></p>

<p>这个题刚看到的时候我是懵逼的……着实被题解惊艳到了，完全想不到还有这么优美的解法。
这些解法来自各位dalao的题解，整理如下。</p>


        <a href="/2017/07/31/buylow" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/07/25/homerange" style="color:#154;"> <h1>[USACO]家的范围</h1> </a>
        <p>链接：
<a href="https://www.luogu.org/problem/show?pid=2733">Luogu-P2733</a></p>

<h2 id="题意">题意</h2>

<p>在正方形的区域内，有一些点有标记，求出边长大于等于2的，内部没有标记的每种不同正方形个数。正方形可以重叠。</p>

<h2 id="分析">分析</h2>

<ul>
  <li>不同正方形的个数？
我们知道DP题目的常用方法是“看题说话”。我们可以根据题目信息直接定义状态吗？确定这个区域内的某一个正方形的两个量，分别是右下角（或者左上角等）的位置<script type="math/tex">(x,y)</script>，以及它的边长。但是，以两者中的任意一个定义状态，都不方便写出转移方程。
怎么办呢？</li>
</ul>


        <a href="/2017/07/25/homerange" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/07/24/strdist" style="color:#154;"> <h1>字串距离</h1> </a>
        <p>链接：<a href="https://www.luogu.org/problem/show?pid=1279">Luogu-1279</a></p>

<h2 id="思路">思路</h2>
<p>如何实现“插入空格”操作？</p>

<p>定义状态为<script type="math/tex">f(i,j)</script>，表示字符串A中从第<script type="math/tex">i</script>个字符到结尾，字符串B中从第<script type="math/tex">j</script>个字符到结尾，所能得到的最小字串距离。显然，可以把<script type="math/tex">i,j</script>都前移，也就是转移到<script type="math/tex">f(i+1,j+1)</script>。那空格怎么处理呢？我们用<script type="math/tex">i,j</script>中的一个加1，另一个不变，来表示在某个字符的前面插入一个空格。</p>


        <a href="/2017/07/24/strdist" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/07/24/seqlcs" style="color:#154;"> <h1>排列LCS</h1> </a>
        <p>题目链接：<a href="https://www.luogu.org/problem/show?pid=1439">Luogu-P1439</a></p>

<h2 id="思路">思路</h2>

<p>按照题目中数据规模，直接跑LCS，复杂度为<script type="math/tex">O(n^2)</script>，只有50分。</p>

<p>考虑到题目中给定的是两个排列，应该可以利用排列的某些性质。</p>

<p>如果其中一个排列是<script type="math/tex">1,2,3,...,N</script>，那么显然LCS就是另一个排列的LIS。</p>


        <a href="/2017/07/24/seqlcs" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/07/23/number" style="color:#154;"> <h1>[NOIP2000]方格取数</h1> </a>
        <p>链接：<a href="https://www.luogu.org/problem/show?pid=1004">Luogu-P1004</a></p>

<h2 id="思路">思路</h2>

<p>考虑换成两次都从(0,0)出发 ，向右/下行走。
显然两者到达终点时走过的步数相同。
因此可以让二者每次都走一步，分4种情况讨论。
注意由于步数相同不可能二者位于同一列上下相邻两格。
于是唯一的特殊情况就是二者处于同一个格子，这时这个格子的数只能取一次。
特判处理即可。</p>


        <a href="/2017/07/23/number" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/07/23/missile" style="color:#154;"> <h1>[NOIP1999]导弹拦截</h1> </a>
        <p>链接：<a href="https://www.luogu.org/problem/show?pid=1020">Luogu-P1020</a></p>

<h2 id="思路">思路</h2>

<p>第一问是裸的最长下降子序列问题。</p>

<p>第二问：</p>

<p>Dilworth 定理：</p>
<blockquote>
  <p>最长不降子序列长度，等于下降子序列划分数的最小值。</p>
</blockquote>

<p>其对偶定理，即</p>
<blockquote>
  <p>最长下降子序列长度，等于不降子序列划分数的最小值。</p>
</blockquote>

<p>同样成立。</p>

<p>我也不知道怎么证明的，要用到偏序集。但是因为和LIS问题有关，先记下来。</p>

<p>第二问需用到此定理。</p>

<p>最少需要的导弹系统数，实际上就等于最长不降子序列的长度。</p>


        <a href="/2017/07/23/missile" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/07/22/monotonic-ds" style="color:#154;"> <h1>单调数据结构学习笔记</h1> </a>
        <p>这里的“单调数据结构”，指的就是单调栈和单调队列。</p>

<h2 id="单调栈">单调栈</h2>

<h3 id="特点">特点</h3>

<p>先进的元素后出，求前/后缀最值。</p>

<h3 id="实现">实现</h3>

<p>使用一个栈（<del>这不是废话么233</del>），每次在加入栈时维护单调性。不断弹出栈顶元素，直到栈顶元素大于将要加入
的元素，此时再将要加入的元素推入栈中。具体地讲，由于需要随机访问单调栈中的元素，
以便充分利用其单调的特性，常用一个数组来模拟栈。</p>


        <a href="/2017/07/22/monotonic-ds" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/07/22/KMP" style="color:#154;"> <h1>KMP学习笔记</h1> </a>
        <p>推荐Menci神犇的Blog，KMP讲的很清晰。
在这里把Menci的学习<strong>思路</strong>复述一遍，以更好地理解KMP。
<a href="https://oi.men.ci/kmp-notes/">KMP 学习笔记-Menci</a></p>

<h2 id="字符串匹配朴素算法">字符串匹配朴素算法</h2>
<p>字符串匹配就是在目标串中寻找模式串。</p>

<p>在朴素算法中，我们穷举每一个可以开始匹配的位置，然后逐一比较，如果无法匹配就向右移动一位模式串,直到找到匹配或者所有位置都无法匹配位置。</p>


        <a href="/2017/07/22/KMP" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/07/14/Plan" style="color:#154;"> <h1>Todo List</h1> </a>
        <p>写给自己的话：
注意建模能力的训练，掌握每种算法对应题目的特点。学时优先看书。
写之前一定要考虑时间复杂度，想好再写！</p>

<p>欢迎监督QAQ</p>


        <a href="/2017/07/14/Plan" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/07/12/VanTrans" style="color:#154;"> <h1>[NOIP2013]货车运输</h1> </a>
        <p>题目链接：<a href="http://codevs.cn/problem/3287/">CodeVS 3287</a></p>

<p>题意：给出一张无向图，每条边有一个边权，图上可以有重边，没有自环。求这张图上两点<script type="math/tex">u</script>,<script type="math/tex">v</script>之间所有路径上最小权值的最大值。若不能互相到达输出-1。</p>
<h2 id="1审题">1.审题</h2>
<ol>
  <li>显然，无向图不一定是连通图，于是两点之间若要互相到达，必须在同一连通子图上。</li>
  <li>最小权值的最大值：图上<script type="math/tex">u</script>,<script type="math/tex">v</script>两点间有着多条路径，需要找到一条路径，这条路径上所求的权值最小的边最大。</li>
</ol>


        <a href="/2017/07/12/VanTrans" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
      <li>
        <div class="article-inner">
        <a href="/2017/07/11/HelloWorld" style="color:#154;"> <h1>Hello,World</h1> </a>
        <p>你好，我是panda_2134，一名高二的OIer，目前正在准备省选。想拿NOI金牌。</p>

<blockquote>
  <p>欲得其上，必取其中。</p>
</blockquote>

<blockquote>
  <p>但行好事，莫问前程。</p>
</blockquote>

<p>望你我共勉。</p>

<p><strong>2018/2/19</strong></p>

<p>WC考挂，Cu滚粗咯</p>

<p>看省选咯</p>

        <a href="/2017/07/11/HelloWorld" style="color:#000;"> <b>Read More...</b> </a>
        </div>
      </li>
      
    </ul>
    <hr/>
  </div>
</div>


      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="http://github.com/panda2134/panda2134.github.io">panda2134.github.io</a> is maintained by <a href="http://github.com/panda2134">panda2134</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </section>

    
  </body>
</html>
